import vm/parser;
import ds/array;
import ds/dlist;

export {
    Node(label: int, values: Tree<string, Value>);
    Value ::= ValueInt, ValueArr;
    ValueInt(v: int);
    ValueArr(a: [Value]);

    exec(prog: VnemoProg) -> DList<Node>;

    initVarsDefault(decls: [VnemoVarDecl]) -> Tree<string, Value>;
}

opValues(op: string, l: Value, r: Value) -> Maybe<int> {
    switch(l) {
        ValueArr(al): None()
        ValueInt(vl): switch(r) {
            ValueArr(ar): None()
            ValueInt(vr): {
                if(op == "+") Some(vl + vr)
                else if(op == "-") Some(vl - vr)
                else if(op == "*") Some(vl * vr)
                else if(op == "/") if(vr != 0) Some(vl / vr) else None()
                else if(op == "%") Some(vl % vr)
                else None()
            }
        }
    }
}

computeExpr(e: VnemoExpr, t: Tree<string, Value>) -> Maybe<Value> {
    switch(e) {
        VnemoBinOp(op, l, r): {
            c_l = computeExpr(l, t);
            c_r = computeExpr(r, t);
            switch(c_l) {
                None(): None()
                Some(lv): switch(c_r) {
                    None(): None()
                    Some(rv): switch(opValues(op, lv, rv)) {
                        None(): None()
                        Some(rez): Some(ValueInt(rez))
                    }
                }
            }
        }
        VnemoApp(arr, i): switch(computeExpr(arr, t)) {
            None(): None()
            Some(v): switch(v) {
                ValueInt(val): None()
                ValueArr(a): switch(computeExpr(i, t)) {
                    None(): None()
                    Some(vi): switch(vi) {
                        ValueArr(ai): None()
                        ValueInt(index):
                            if(index < length(a)) { Some(a[index]) }
                            else { None() }
                    }
                }
            }
        }
        VnemoUpd(arr, i, v): switch(computeExpr(arr, t)) {
            None(): None()
            Some(val): switch(val) {
                ValueInt(value): None()
                ValueArr(a): switch(computeExpr(i, t)) {
                    None(): None()
                    Some(vi): switch(vi) {
                        ValueArr(ai): None()
                        ValueInt(index): switch(computeExpr(v, t)) {
                            None(): None()
                            Some(rez_v): {
                                if(index < length(a)) { Some(ValueArr(replace(a, index, rez_v))) }
                                else if(index == length(a)) { Some(ValueArr(concat(a, [rez_v]))) }
                                else { None() }
                            }
                        }
                    }
                }
            }
        }
        VnemoConst(val): Some(ValueInt(val))
        VnemoVar(name): switch(lookupTree(t, name)) {
            None(): None()
            Some(v): Some(v)
        }
    }
}

computeCondition(o: VnemoCond, t: Tree<string, Value>) -> Maybe<bool> {
    c_le = computeExpr(o.le, t);
    c_re = computeExpr(o.re, t);
    switch(c_le) {
        None(): None()
        Some(v_le): switch(c_re) {
            None(): None()
            Some(v_re): {
                if(o.op == "==") Some(v_le == v_re)
                else if(o.op == "<=") Some(v_le <= v_re)
                else if(o.op == ">=") Some(v_le >= v_re)
                else if(o.op == "<") Some(v_le < v_re)
                else if(o.op == ">") Some(v_le > v_re)
                else if(o.op == "!=") Some(v_le != v_re)
                else None()
            }
        }
    }
}

getOperByLabel(label: int, prog: VnemoProg) -> Maybe<VnemoOper> {
    find(prog.operators, \ oper -> {
        switch(oper) {
            VnemoIfElse(l, cond, lm, rm): {
                if(l == label) true
                else false
            }
            VnemoPrint(l, e, marks): {
                if(l == label) true
                else false
            }
            VnemoAssign(l, var, val, marks): {
                if(l == label) true
                else false
            }
        }
    })
}

arr2str(arr: Value) -> string {
    switch(arr) {
        ValueInt(v): i2s(v)
        ValueArr(a): "[" + fold(a, "", \ s, v -> {s + " " + arr2str(v)}) + "]"
    }
}

printTree(e: VnemoExpr, t: Tree<string, Value>) -> void {
    switch(computeExpr(e, t)) {
        None(): println("Bad expression!");
        Some(v): switch(v) {
            ValueInt(val): println(val);
            ValueArr(arr): println(arr2str(v));
        }
    }
}

updateNode(node: Node, prog: VnemoProg) -> Pair<bool, DList<Node>> {
    operator = getOperByLabel(node.label, prog);
    result = switch(operator) {
        None(): Pair(false, Some([node]))
        Some(v): switch(v) {
            VnemoIfElse(l, cond, lm, rm): switch(computeCondition(cond, node.values)) {
                None(): Pair(false, None())
                Some(rez): if(rez) {
                    Pair(true, Some(map(lm, \ label -> { Node(label.val, node.values) })))
                } else {
                    Pair(true, Some(map(rm, \ label -> { Node(label.val, node.values) })))
                }
            }
            VnemoPrint(l, e, marks): { printTree(e, node.values);
                Pair(true, Some(map(marks, \ label -> { Node(label.val, node.values) })))
            }
            VnemoAssign(l, var, e, marks): {
                switch(computeExpr(e, node.values)) {
                    None(): Pair(false, None())
                    Some(val): switch(lookupTree(node.values, var.name)) {
                        None(): Pair(false, None())
                        Some(var_val): {
                            upd_tree = setTree(node.values, var.name, val);
                            Pair(true, Some(map(marks, \ label -> { Node(label.val, upd_tree) })))
                        }
                    }
                }
            }
        }
    }
    Pair(result.first, switch(result.second) {
        None(): makeDList()
        Some(array): fold(array, makeDList(), \ q, n -> { pushDList(q, n); q})
    })
}

initVarsDefault(decls: [VnemoVarDecl]) -> Tree<string, Value> {
    fold(decls, makeTree(), \ tree, v -> switch(v.type) {
        VnemoIntType(): setTree(tree, v.name, ValueInt(0))
        VnemoArrayType(type): setTree(tree, v.name, ValueArr([]))
    })
}

exec(prog: VnemoProg) -> DList<Node> {
    node = Node(0, initVarsDefault(prog.decls));
    queue = makeDList();
    pushDList(queue, node);
    for(queue, \ q -> { !isEmptyDList(q) }, \ q -> {
        switch(popFirstDList(q)) {
            None(): makeDList()
            Some(v): {
                newQueue =  updateNode(v, prog);
                if(newQueue.first) {
                    concatDList(q, newQueue.second);
                    q
                } else { 
                    q 
                }
            }
        }
    });
}