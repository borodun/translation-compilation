import runtime;
import string;
import lingo/pegcode/driver;
import math/math;

export {
    Type ::= Int, Array;
    Int();
    Array(type: Type);
    Mark(val: int);

    Expr ::= BinOp, Const, App, Upd, Var;
    BinOp(op: string, le: Expr, re: Expr);
    App(ae: Expr, ie: Expr);
    Upd(ae: Expr, ie: Expr, ve: Expr);
    Const(val: int);
    Var(name: string);

    Oper ::= IfElse, Print, Assign;
    CondOp(op: string, le: Expr, re: Expr);
    IfElse(mark: int, cond: CondOp, lm: [Mark], rm: [Mark]);
    Print(mark: int, e: Expr, marks: [Mark]);
    Assign(mark: int, var: Var, val: Expr, marks: [Mark]);

    VarDecl(name: string, type: Type);

    Prog(decls: [VarDecl], operators: [Oper]);

    str2prog(s: string) -> Maybe<Prog>;
    printProg(p: Prog) -> void;
    prog2str(p: Prog) -> string;
}

str2prog(s: string) -> Maybe<Prog> {
    gram = "#include vm/vm.lingo";
    result = parsic3(compilePegGrammar(gram), s, defaultPegActions, Prog([VarDecl("x", Int())], [Assign(0, Var("x"), Const(0), [Mark(0)])]));
    if (result.third == "") {
        Some(result.first);
    }
    else{ 
        println("Error on position "+ i2s(result.second) + ":\n" + result.third);
        None();
    }
}

type2str(t: Type) -> string {
    switch(t) {
        Int(): "int"
        Array(next): "[" + type2str(next) + "]"
    }
}

expr2str(e: Expr) -> string {
    switch(e) {
        BinOp(op, le, re): "(" + expr2str(le) + " " + op + " " + expr2str(re) + ")"
        App(ae, ie): "(app(" + expr2str(ae) + ", " + expr2str(ie) + "))"
        Upd(ae, ie, ve): "(upd(" + expr2str(ae) + ", " + expr2str(ie) + ", " + expr2str(ve) + "))"
        Const(v): i2s(v)
        Var(name): name
    }
}

condOp2str(o: CondOp) -> string {
    expr2str(o.le) + " " + o.op + " " + expr2str(o.re)
}

oper2str(o: Oper) -> string {
    switch(o) {
        IfElse(mark, cond, lm, rm): {
            lmStr = fold(map(lm, \v -> i2s(v.val)), "", \v, acc -> acc + ", " + v);
            rmStr = fold(map(rm, \v -> i2s(v.val)), "", \v, acc -> acc + ", " + v);
            i2s(mark) + ": " + "if (" + condOp2str(cond) + ") then goto {"
                + strSubRange(lmStr, 0, strlen(lmStr) - 2) + "} else goto {"
                + strSubRange(rmStr, 0, strlen(lmStr) - 2) + "};"
        }
        Print(mark, e, marks): {
            marksStr = fold(map(marks, \v -> i2s(v.val)), "", \v, acc -> acc + ", " + v);
            i2s(mark) + ": " + "print(" + expr2str(e) + ")" +
                " goto {" + strSubRange(marksStr, 0, strlen(marksStr) - 2) + "};"
        }
        Assign(mark, var, val, marks): {
            marksStr = fold(map(marks, \v -> i2s(v.val)), "", \v, acc -> acc + ", " + v);
            i2s(mark) + ": " + expr2str(var) + " = " + expr2str(val) +
                " goto {" + strSubRange(marksStr, 0, strlen(marksStr) - 2) + "};"
        }
    }
}

printProg(p: Prog) -> void {
    iter(p.decls, \v -> println("var " + v.name + ": " + type2str(v.type)  + ";"));
    iter(p.operators, \v -> println(oper2str(v)));
}

prog2str(p: Prog) -> string {
    fold(p.decls, "", \ acc, v -> { acc + "var " + v.name + ": " + type2str(v.type)  + ";\n" })
    +
    fold(p.operators, "", \ acc, v -> { acc + oper2str(v) + "\n" });
}