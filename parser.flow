import lingo/pegcode/driver;

export {
    Type ::= IntType, ArrayType;
    IntType();
    ArrayType(type: Type);

    Expr ::= BinOpExpr, ConstExpr, VarExpr;
    BinOpExpr(op: string, le: Expr, re: Expr);
    ConstExpr(val: int);
    VarExpr(name: string);

    Oper ::= CondOper, SeqOper, PrintOper, AssignOper, ChoiceOper, LoopOper;
    CondOper(op: string, le: Expr, re: Expr);
    SeqOper(o: [Oper]);
    ChoiceOper(o: [Oper]);
    LoopOper(o: Oper);
    PrintOper(e: Expr);
    AssignOper(var: VarExpr, val: Expr);

    VarDecl(name: string, type: Type);

    Prog(decls: [VarDecl], operators: Oper);

    str2Prog(s: string) -> Prog;
}

seqSemanticAct(xs: [flow]) -> SeqOper {
    SeqOper(concat([xs[0]], xs[1]))
}

choiceSemanticAct(xs: [flow]) -> ChoiceOper {
    ChoiceOper(concat([xs[0]], xs[1]))
}

negoper(o: string) -> string {
    if(o == "==") "!="
    else if(o == "<=") ">"
    else if(o == ">=") "<"
    else if(o == "<") ">="
    else if(o == ">") "<="
    else if(o == "!=") "=="
    else o
}

ifelseSemanticAct(xs: [flow]) -> ChoiceOper {
    ChoiceOper([SeqOper([CondOper(xs[0], xs[1], xs[2]), xs[3]]),
        SeqOper([CondOper(negoper(xs[0]), xs[1], xs[2]), xs[4]])])
}

whileSemanticAct(xs: [flow]) -> SeqOper {
    SeqOper([LoopOper(SeqOper([CondOper(xs[0], xs[1], xs[2]), xs[3]])),
        CondOper(negoper(xs[0]), xs[1], xs[2])])
}

str2Prog(s: string) -> Prog {
    specialPegActions = {
        t1 = setTree(defaultPegActions.t, "seqSemanticAct", seqSemanticAct);
        t2 = setTree(t1, "choiceSemanticAct", choiceSemanticAct);
        t3 = setTree(t2, "ifelseSemanticAct", ifelseSemanticAct);
        t4 = setTree(t3, "whileSemanticAct", whileSemanticAct);
        SemanticActions(t4);
    }
    gram = "#include nemo.lingo";
    parsic(compilePegGrammar(gram), s, specialPegActions);
    // if (result.third == "") {
    //     result.first;
    // }
    // else{ 
    //     println("Error: " + result.third)
    // }
}

type2str(t: Type) -> string {
    switch(t) {
        IntType(): "int"
        ArrayType(next): "[" + type2str(next) + "]"
    }
}

expr2str(e: Expr) -> string {
    switch(e) {
        BinOpExpr(op, le, re): "(" + expr2str(le) + op + expr2str(re) + ")"
        ConstExpr(v): i2s(v)
        VarExpr(name): name
    }
}

oper2str(o: Oper) -> string {
    switch(o) {
        CondOper(op, l, r): "(" + expr2str(l) + " " + op + " " + expr2str(r) + ")?"
        PrintOper(e): "print(" + expr2str(e) + ")"
        AssignOper(var, val): "(" + expr2str(var) + " = " + expr2str(val) + ")"
        LoopOper(l): oper2str(l) + "*"
        SeqOper(s): "{" + fold(s, "", \ acc, v -> acc + "; " + oper2str(v)) + "}"
        ChoiceOper(c): "{" + fold(c, "", \ acc, v -> acc + " U " + oper2str(v)) + "}"
    }
}

printProgStruct(p: Prog) -> void {
    iter(p.decls, \v -> println("var " + v.name + ": " + type2str(v.type)  + ";"));
    println(oper2str(p.operators));
}